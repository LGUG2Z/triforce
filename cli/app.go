package cli

import (
	"strings"

	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"time"

	"path"

	"github.com/Jeffail/gabs"
	"github.com/urfave/cli"
)

type TriforcePackageJSON struct {
	Name            string            `json:"name"`
	Description     string            `json:"description"`
	Dependencies    map[string]string `json:"dependencies"`
	DevDependencies map[string]string `json:"devDependencies"`
}

const PackageJSON = "package.json"
const NodeModules = "node_modules"

func App() *cli.App {
	app := cli.NewApp()
	app.Name = "triforce"
	app.Usage = "assembles and links node dependencies across meta and monorepo projects"
	app.UsageText = "triforce command [command options] [arguments...]"
	app.HideVersion = true
	app.Compiled = time.Now()
	app.Authors = []cli.Author{{
		Name:  "J. Iqbal",
		Email: "jade@beamery.com",
	}}

	app.Commands = []cli.Command{
		Assemble(),
		Link(),
	}

	return app
}

func Assemble() cli.Command {
	return cli.Command{
		Name:  "assemble",
		Usage: "assembles the dependencies and devDependencies across all projects into a single package.json file",
		Flags: []cli.Flag{
			cli.StringSliceFlag{Name: "exclude", Usage: "patterns to exclude in versions", Value: &cli.StringSlice{"github", "gitlab", "bitbucket"}},
		},
		Action: func(c *cli.Context) error {
			if c.NArg() != 1 {
				return fmt.Errorf("triforce assemble requires a root meta or monorepo folder as an argument")
			}

			root, err := filepath.Abs(c.Args().First())
			if err != nil {
				return err
			}

			exclude := c.StringSlice("exclude")

			var parsedPackageJSONs []*gabs.Container
			dependencies := make(map[string]string)
			devDependencies := make(map[string]string)

			projectDirectories, err := getProjectFolders(root)
			if err != nil {
				return err
			}

			for _, projectDirectory := range projectDirectories {
				pkgPath := filepath.Join(root, projectDirectory, PackageJSON)
				if _, err := os.Stat(pkgPath); err == nil {
					parsed, err := gabs.ParseJSONFile(pkgPath)
					if err != nil {
						return err
					}

					parsedPackageJSONs = append(parsedPackageJSONs, parsed)
				}
			}

			for _, parsed := range parsedPackageJSONs {
				extractDependencies(parsed, dependencies, exclude)
			}

			for _, parsed := range parsedPackageJSONs {
				extractDevDependencies(parsed, dependencies, devDependencies, exclude)
			}

			t := TriforcePackageJSON{
				Name:            fmt.Sprintf("triforce-%s", filepath.Base(root)),
				Description:     fmt.Sprintf("automatically generated by triforce"),
				Dependencies:    dependencies,
				DevDependencies: devDependencies,
			}

			bytes, err := json.MarshalIndent(t, "", "  ")
			if err != nil {
				return err
			}

			return ioutil.WriteFile("package.json", bytes, os.FileMode(0644))
		},
	}
}

func Link() cli.Command {
	return cli.Command{
		Name:  "link",
		Usage: "links private projects inside of the node_modules folder at the meta or monorepo project root",
		Action: cli.ActionFunc(func(c *cli.Context) error {
			if c.NArg() != 1 {
				return fmt.Errorf("triforce link requires a root meta or monorepo folder as an argument")
			}

			root, err := filepath.Abs(c.Args().First())
			if err != nil {
				return err
			}

			nodeModules := filepath.Join(root, NodeModules)
			if _, err := os.Stat(nodeModules); err != nil {
				return fmt.Errorf("no node_modules folder found at %s", root)
			}

			projectFolders, err := getProjectFolders(root)
			if err != nil {
				return err
			}

			for _, f := range projectFolders {
				// if it is a node project
				pkgPath := filepath.Join(root, f, PackageJSON)
				if _, err := os.Stat(pkgPath); err == nil {
					projectDirectory := path.Join("..", f)
					symlinkDestination := filepath.Join(nodeModules, f)

					if err := os.Symlink(projectDirectory, symlinkDestination); err != nil {
						return err
					}
				}
			}

			return nil
		}),
	}
}

func getProjectFolders(root string) ([]string, error) {
	var projectDirectories []string
	dirs, err := ioutil.ReadDir(root)
	if err != nil {
		return nil, err
	}

	for _, d := range dirs {
		// ignore non-directories and hidden files
		if d.IsDir() && !strings.HasPrefix(d.Name(), ".") {
			projectDirectories = append(projectDirectories, d.Name())
		}
	}

	return projectDirectories, nil
}

func isAPrivateDependency(version string, exclude ...string) bool {
	for _, pattern := range exclude {
		if strings.Contains(strings.ToLower(version), strings.ToLower(pattern)) {
			return true
		}
	}

	return false
}

func extractDependencies(parsed *gabs.Container, dependencies map[string]string, exclude []string) {
	if data, ok := parsed.Path("dependencies").Data().(map[string]interface{}); ok {
		for dep, version := range data {
			if isAPrivateDependency(version.(string), exclude...) {
				continue
			}

			// Update in dependencies if it is a greater version
			if val, ok := dependencies[dep]; ok {
				if version.(string) > val {
					dependencies[dep] = version.(string)
				}
			} else {
				// Otherwise add for the first time
				dependencies[dep] = version.(string)
			}
		}
	}
}

func extractDevDependencies(parsed *gabs.Container, dependencies, devDependencies map[string]string, exclude []string) {
	if data, ok := parsed.Path("devDependencies").Data().(map[string]interface{}); ok {
		for devDep, version := range data {
			if isAPrivateDependency(version.(string), exclude...) {
				continue
			}

			// Update in dependencies if it is a greater version
			if val, ok := dependencies[devDep]; ok {
				if version.(string) > val {
					dependencies[devDep] = version.(string)
				}
				continue
			}

			// Otherwise update in devDependencies if the version is greater
			if val, ok := devDependencies[devDep]; ok {
				if version.(string) > val {
					devDependencies[devDep] = version.(string)
				}
			} else {
				// Otherwise add for the first time
				devDependencies[devDep] = version.(string)
			}
		}
	}
}
